# Using Explicit Interface as an Adapter

## Example Structure

There example contains two projects:
 
  * `plugin` stands for the example of framework
  * `client` application that uses (in our cse just tests) the framework
 
The project `plugen` is not aware about the project `client`. Thus, you can
apply `plugin` to any other application.

### Plugin Project 

Here is an example of a tree generated by 
[Uniform Factory](https://github.com/antkudruk/uniformfactory).

Supposing we have callbacks in some classes. 
We'll mark the classes with `@Marker` annotation and processing methods with 
`@Callback` annotation. 

To call each callback method we'll use the following trick.
We'll introduce an additional wrapper interface to call each event handler in
the same way. Each method annotated with `@Processor.Process` annotation will
cause creation of a type implementing `Processor` interface. The method of that
interface will be invoking the corresponding origin method.

Note that the interface may contain one and only one method 

```
public interface Processor {

    @Retention(RetentionPolicy.RUNTIME)
    @Target({ElementType.METHOD, ElementType.FIELD})
    @interface Process {

    }

    boolean process(String eventName);
}
```

Wrapper method will return list containing functional interface objects, in our 
case it will be a `List` of `Processor`s.   

```
public interface Wrapper {
    List<Processor> getProcessors();
}
```

To specify a way of implementing `getProcessors` method we'll use the same 
builder as we used for `MethodSingleton` specifying in `addMethodList` is the 
returning type of the **functional** interface.

```
public class ClassFactoryGeneratorImpl extends DefaultMetaClassFactory<Wrapper> {
    public ClassFactoryGeneratorImpl() throws NoSuchMethodException {
        this.classFactory = new ClassFactory.ShortcutBuilder<>(Wrapper.class)
                .addMethodList(
                        Wrapper.class.getMethod("getProcessors"),
                        boolean.class
                )
                .setMarkerAnnotation(Processor.Process.class)
                .setFunctionalInterface(Processor.class)
                .addResultTranslator(void.class, t -> true)
                .addResultTranslator(Long.class, t -> t >= 0)
                .addResultTranslator(String.class, "yes"::equalsIgnoreCase)
                .endMethodDescription()

                .build());
    }
}
```

In this case each *result mapper* should map an arbitary *origin method* 
return type to the method result in the *functional* interface.
