# Method List

## Example Structure

There example contains two projects:
 
  * `plugin` stands for the example of framework
  * `client` application that uses (in our cse just tests) the framework
 
The project `plugen` is not aware about the project `client`. Thus, you can
apply `plugin` to any other application.

### Plugin Project 

Here is an example of a tree generated by 
[Uniform Factory](https://github.com/antkudruk/uniformfactory).

Supposing we have callbacks in some classes. 
We'll mark the classes with `@Marker` annotation and processing methods with 
`@Callback` annotation. 

To call each callback method we'll use the following trick.
We'll introduce an additional wrapper interface to call each event handler in
the same way. Each method annotated with `@Processor.Process` annotation will
cause creation of a type implementing `Processor` interface. The method of that
interface will be invoking the corresponding origin method.

Note that the interface may contain one and only one method 

```
public interface Processor {

    @Retention(RetentionPolicy.RUNTIME)
    @Target({ElementType.METHOD, ElementType.FIELD})
    @interface Process {

    }

    boolean process(String eventName);
}
```

Wrapper method will return list containing functional interface objects, in our 
case it will be a `List` of `Processor`s.   

```
public interface Wrapper {
    List<Processor> getProcessors();
}
```

To specify a way of implementing `getProcessors` method we'll use the same 
builder as we used for `MethodSingleton` specifying in `addMethodList` is the 
returning type of the **functional** interface.

```
public class ClassFactoryGeneratorImpl extends DefaultMetaClassFactory<Wrapper> {
    public ClassFactoryGeneratorImpl() throws NoSuchMethodException {
        this.classFactory = new ClassFactory.Builder<>(Wrapper.class)
                .addMethodList(Wrapper.class.getMethod("getProcessors"), Processor.class)
                .defaultElementSource()
                .setMarkerAnnotation(Processor.Process.class)

                // Setting up element factory for the list - getters
                .getterElementFactory(Boolean.class)

                // Descrives how to map results from origin methods to the adapter methd result
                .addResultTranslator(void.class, t -> true)
                .addResultTranslator(Long.class, t -> t >= 0)
                .addResultTranslator(String.class, "yes"::equalsIgnoreCase)
                .addResultTranslator(Boolean.class, t -> t)

                // Describes how to map parameters from the adapter method to origin methods
                .parameterSource(String.class, 0)
                .applyTo(new AnyParameterFilter())
                .addTranslator(Integer.class, Integer::parseInt)
                .finishParameterDescription()

                .finishElementFactory()
                .endElementSource()
                .endMethodDescription()
                .build();
    }
}
```

In this case each *result mapper* should map an arbitary *origin method* 
return type to the method result in the *functional* interface.
