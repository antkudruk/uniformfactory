# Application: Object Tree

## Example Structure

There example contains two projects:
 
  * `plugin` stands for the example of framework
  * `client` application that uses (in our cse just tests) the framework
 
The project `plugen` is not aware about the project `client`. Thus, you can
apply `plugin` to any other application.

### Plugin Project 

Here is an example of a tree generated by 
[Uniform Factory](https://github.com/antkudruk/uniformfactory).

Let's consider an example.
Supposing we have the following structure of objects.
We have a Company. The company has some Departments and each department
has a list of employee.

```
@TreeElementMarker
public class Company {

    @Label
    private static final String companyName = "My awesome company";

    @Nested
    public List<Department> getDepartments() {
        return Arrays.asList(
                new Department("Managers", "Beavis", "Butthead"),
                new Department("Labours", "Stewart")
        );
    }
}

@TreeElementMarker
public class Department {

    @Label
    private final String depName;

    @Nested
    private final List<Employee> employee;

    public Department(String depName, String... employee) {
        this.depName = depName;
        this.employee = Stream.of(employee)
                .map(Employee::new)
                .collect(Collectors.toList());
    }
}

@TreeElementMarker
public class Employee {
    @Label
    private final String name;

    public Employee(String name) {
        this.name = name;
    }
}

```

To display this structure of object in the common way it's suitable to assign
a wrapper to each of the objects that will allow you to get nested elements and
labels for each element using the common interface

```
// Wrapper interface
public interface TreeElement {
    String getLabel();
    List<HasTreeElement> nested();
}

// Origin interface
public interface HasTreeElement {
    TreeElement getTreeElement();
}
``` 

The example to get this structure is quite straightforward.
Note that in the following listing `nested()` method is assigned with default 
value. If no nested methods are defined in the origin class (like in Employee 
class in the listing above), the corresponding **wrapper** object will contain
an empty list of children.

```
public class ClassFactoryGeneratorImpl extends DefaultMetaClassFactory<TreeElement> {
    public ClassFactoryGeneratorImpl() throws ReflectiveOperationException {
        super(new ClassFactory.Builder<>(TreeElement.class)
                .addMethodSingleton(TreeElement.class.getMethod("getLabel"), String.class)
                .setMarkerAnnotation(Label.class)
                .endMethodDescription()

                .addMethodSingleton(TreeElement.class.getMethod("nested"), List.class)
                .setMarkerAnnotation(Nested.class)
                .setDefaultValue(new ArrayList<>())
                .endMethodDescription()

                .build());
    }
}
```

Once you used the classes above, you'll be able to iterate the elements like in
the following listing. Keep in mind that the method `nested()` returns list of 
**origin** objects implementing `HasTreeElement` interface, but not 
`TreeElement`. To access `TreeElement`, you should just call `getTreeElement()`
method explicitly.   

```
Company company = new Company();
        HasTreeElement tree = (HasTreeElement) company;
        assertEquals("Managers", tree.getTreeElement()
                .nested().get(0).getTreeElement().getLabel());
        assertEquals("Beavis", tree.getTreeElement()
                .nested().get(0).getTreeElement()
                .nested().get(0).getTreeElement().getLabel());
        assertEquals("Butthead", tree.getTreeElement()
                .nested().get(0).getTreeElement()
                .nested().get(1).getTreeElement().getLabel());
        assertEquals("Labours", tree.getTreeElement()
                .nested().get(1).getTreeElement().getLabel());
        assertEquals("Stewart", tree.getTreeElement()
                .nested().get(1).getTreeElement()
                .nested().get(0).getTreeElement().getLabel());
```
